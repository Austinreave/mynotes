#### 锁

+ 单进程的系统中，存在多线程同时操作一个公共变量，此时需要加锁对变量进行同步操作，保证多线程的操作线性执行消除并发修改。解决的是单进程中的多线程并发问题。

+ 思考golang的channel和锁的关系：多个goroutine之间通过channel进行通信，管道也运用了锁机制


#### 分布式锁

某些应用场景是在集群模式的多个相同服务，可能会部署在不同机器上，解决进程间安全问题，防止多进程同时操作一个变量或者数据库。解决的是多进程的并发问题。

#### etcd分布式锁实现原理

1. 利用租约在etcd集群中创建一个key，这个key有两种形态，存在和不存在，而这两种形态就是互斥量。
2. 如果这个key不存在，那么线程创建key，成功则获取到锁，该key就为存在状态。
3. 如果该key已经存在，那么线程就不能创建key，则获取锁失败。

#### 数据库乐观锁（适用于并发不是很大的场景）

1. 在数据表里面加一个版本号字段，默认为1，只有版本号为1时才能操作这条数据
2. 当有进程操作时，先将版本号设置成2
3. 当这个进程处理完所有业务时，再将版本号设置为1
4. 其他进程如果发现版本号为1时：则使用重试机制（一般循环三次就可以，概率问题）

#### 数据库悲观锁（消耗性能）

利用mysql自己的锁机制：for update和事务处理

