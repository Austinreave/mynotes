####  一些概念

1. 锁

   + 单进程的系统中，存在多线程同时操作一个公共变量，此时需要加锁对变量进行同步操作，保证多线程的操作线性执行消除并发修改。解决的是单进程中的多线程并发问题。

   + 思考golang的channel和锁的关系
     + 多个goroutine之间通过channel进行通信，管道也运用了锁机制

2. 分布式锁

   某些应用场景是在集群模式的多个相同服务，可能会部署在不同机器上，解决进程间安全问题，防止多进程同时操作一个变量或者数据库。解决的是多进程的并发问题。

3. 事务

   解决一个会话过程中，上下文的修改对所有数据库表的操作要么全部成功，要不全部失败。在互联网应用中，常常用补偿逻辑来替代事务回滚

#### 为什么需要分布式锁

1. 有状态的数据修改操作时要考虑并发冲突

#### 怎样结局分布式锁

1. etcd进行维护（适用于并发大的场景）
   1. etcd分布式锁实现原理
      1. 利用租约在etcd集群中创建一个key，这个key有两种形态，存在和不存在，而这两种形态就是互斥量。
      2. 如果这个key不存在，那么线程创建key，成功则获取到锁，该key就为存在状态。
      3. 如果该key已经存在，那么线程就不能创建key，则获取锁失败。
2. 数据库乐观锁（适用于并发不是很大的场景）
   1. 在数据表里面加一个版本号字段，默认为1，只有版本号为1时才能操作这条数据
   2. 当有进程操作时，先将版本号设置成2
   3. 当这个进程处理完所有业务时，再将版本号设置为1
   4. 其他进程如果发现版本号为1时：则使用重试机制（一般循环三次就可以，概率问题）
3. 数据库悲观锁（消耗性能）
   1. 利用mysql自己的锁机制
      1. for update
      2. 事务处理

