+ go的string在runtime包中就是stringStruct，对外呈现叫做string。  底层也是一个切片类型，由一个长度可变的的集合构成

+ 当申明一个字符串时会在全局区产生一个结构体包含两个变量：

  + 第一个是指针地址`unsafe.Pointer `，这个指针会指向全局的区的常量区内存
  + 第二个是这个指针的长度`len`
  + ![01string原型图](./img\01string原型图.png)

+ 字符串底层是切片类型，为什么打印出来会是字符串呢？下面是转换过程

  + 源码包src/runtime/string.go里的stringStruct定义了string的数据结构：

    + ```
      type stringStruct struct {
         str unsafe.Pointer //字符串的首地址 8字节
         len int //字符串的长度 8字节
      }
      ```

  + 字符串构建过程是先跟据字符串构建stringStruct，再转换成string。转换的源码如下：

    + ```
      // 跟据字符串地址构建string
      func gostringnocopy(str *byte) string {
         // 先构造stringStruct
         ss := stringStruct{str: unsafe.Pointer(str), len: findnull(str)}
         // 再将stringStruct转换成string
         s := *(*string)(unsafe.Pointer(&ss))
         return s
      }
      ```

+ string转[]byte过程
  + string转换成[]byte是将string的内容拷贝一份，新开辟一块内存，但是这个内存是存在虚拟内存区域的，是可以被修改的
    + ![02string转成[]byte](./img\02string转成[]byte.png)

+ []byte转string过程

  + ```
    1. 跟据切片的长度申请内存空间，假设内存地址为p，切片长度为len(b)；
    2. 构建string（string.str = p；string.len = len；）
    3. 拷贝数据(切片中数据拷贝到新申请的内存空间，这个内存空间是存在了常量区)
    ```

  + ![03[]byte转成string](./img\03[]byte转成string.png)

+ 字符串拼接
  + 一个拼接语句的字符串编译时都会被存放到一个切片中，拼接过程需要遍历两次切片，第一次遍 历获取总的字符串长度，据此申请内存，第二次遍历会把字符串逐个拷贝过去。
  + 字符串在拼接的过程中，会新开辟一个常量区空间，将拼接后的字符串存在这个新的空间，如果是追加的话会把原来的那个字符串的空间给回收了
  + 如果两个字符串的内容相等，那么他们会指向同一块内存地址，因为不允许修改又节省资源
  + ![04字符串追加](./img\04字符串追加.png)