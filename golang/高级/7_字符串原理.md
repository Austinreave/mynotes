+ go的string在runtime包中就是stringStruct，对外呈现叫做string，在[]byte上面封装了一层。 

+ 当申明一个字符串时会在全局区产生一个结构体指针`8个字节`指向虚拟内存，包含两个变量：

  + 第一个是指针地址`unsafe.Pointer `指向某个byte切片的首地址，这个指针会指向全局区的常量区内存
  + 第二个是这个指针的长度`len`

    ![01string原型图](../img\01string原型图.png)

+ 字符串底层是切片类型，为什么打印出来会是字符串呢？下面是转换过程

  + 源码包src/runtime/string.go里的stringStruct定义了string的数据结构：

    ```
    type stringStruct struct {
       str unsafe.Pointer //字符串的首地址 8字节 
       len int //int 8字节(64位操作系统时)
    }
    ```

  + 字符串构建过程是先跟据字符串构建stringStruct，再转换成string。转换的源码如下：

    ```
    // 跟据字符串地址构建string
    func gostringnocopy(str *byte) string {
       // 先构造stringStruct
       ss := stringStruct{str: unsafe.Pointer(str), len: findnull(str)}
       // 再将stringStruct转换成string
       s := *(*string)(unsafe.Pointer(&ss))
       return s
    }
    ```

  

+ string转[]byte过程【虚拟内存】

  + string转换成[]byte是将string的内容拷贝一份，新开辟一块内存，但是这个内存是存在虚拟内存区域的，是可以被修改的

    ```
    s:="aaa"
    b := []byte(s)
    b[1] = 98 //修改
    fmt.Println(s) //aaa 不会受影响
    fmt.Println(b) //[97 98 97] 可以被修改
    ```

  ![02string转成[]byte](../img\02string转成[]byte.png)

+ []byte转string过程【常量区】

  + 	1. 跟据切片的长度申请内存空间，假设内存地址为p，切片长度为len(b)；
      	2. 构建string（string.str = p；string.len = len；）
      	3. 拷贝数据：切片中数据拷贝到新申请的内存空间，这个内存空间是存在了常量区
      
      	b := []byte{97,97,97}
      	s:= string(b)
      	b[1] = 98 //修改
      	fmt.Println(s) //aaa 不会受影响
      	fmt.Println(b) //[97 98 97] 可以被修改

  + ![03[]byte转成string](../img\03[]byte转成string.png)

+ 字符串拼接
  + 一个拼接语句的字符串编译时都会被存放到一个切片中，拼接过程需要遍历两次切片，第一次遍历获取总的字符串长度，据此申请内存，第二次遍历会把字符串逐个拷贝过去。
  + 字符串在拼接的过程中，会新开辟一个常量区空间，将拼接后的字符串存在这个新的空间，把原来的那个字符串的空间给回收了。
  + 如果两个字符串的内容相等，那么他们会指向同一块内存地址，因为不允许修改又节省资源。

