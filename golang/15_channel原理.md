#### go语言的CSP模型

+ 这是一种用于描述两个独立的并发实体通过共享的通讯 Channel（管道）进行通信的并发模型。
+ Go的CSP模型实现与原始的CSP实现有点差别：原始的CSP中channel里的任务都是立即执行的，而go语言为其增加了一个缓存，即任务可以先暂存起来，等待执行线程准备好再顺序执行。
+ Go的CSP并发模型，是通过goroutine和channel来实现的。
  + goroutine 是Go语言中并发的执行单位。有点抽象，其实就是和传统概念上的”线程“类似，可以理解为”线程“。
  + channel是Go语言中各个并发结构体(goroutine)之前的通信机制。 通俗的讲，就是各个goroutine之间通信的”管道“，有点类似于Linux中的管道。

#### channel

+ 当申明一个channel时会在全局区产生一个hchan结构体的指针`8个字节`指向虚拟内存
  + buf 环形队列指针：就是管道内的数据在内存中存储的位置
  + sendx和recvx就是元素在这个管道队列里读出和写入的位置
  + recvq：
    + 当多个goroutine在读取某一个管道时会排队读取，如果没有数据则阻塞
    + 被阻塞的goroutine将会挂在channel的等待队列中
    + 因读阻塞的goroutine会被向channel写入数据的goroutine唤醒
  + sendq：
    + 就是当多个goroutinee往管道写数据时会排队写入，如果管道满了则阻塞
    + 被阻塞的goroutine将会挂在channel的等待队列中
    + 因写阻塞的goroutine会被从channel读数据的goroutine唤醒
  + ![01chan数据结构](./img\01chan数据结构.png)

#### 向一个channel中写数据简单过程如下：

1. 如果recvq队列不为空，说明管道里没有数据，那么此时直接从recvq取出G,并把数据写入，最后把该G唤醒，结束发送过程；
2. 如果管道里有空余位置，将数据写入管道里，结束发送过程；

#### 从一个channel读数据简单过程如下：

1.  如果sendq队列不为空，且管道里没有数据，直接从sendq中取出G，把G中数据读出，最后把G唤醒，结束读取过程；
2. 如果sendq队列不为空，管道里数据已满，从管道里首部读出数据，把G中数据写入管道里尾部，把G唤醒，结束读取过程；
3. 如果缓冲区中有数据，则从缓冲区取出数据，结束读取过程

#### 关闭管道

+ 释放所有接收者：将所有读取的goroutine全部销毁，进行垃圾回收
+ 释放所有发送者：将所有写入的goroutine全部销毁，进行垃圾回收

#### 使用channel出现panic的常见场景有

+ 关闭值为nil的channel：因为此时的管道没有启动，所以没法关闭
+ 关闭已经被关闭的channel：因为此时的管道已经关闭，所以没法关闭
+ 向已经关闭的channel写数据：因为此时的管道已经关闭，没法写入
+ 遍历没有关闭的channel：因为接收者和发送者的资源没有进行释放
  + SELECT内置的方默认将channel的资源已经释放所以可以用SELECT遍历管道
