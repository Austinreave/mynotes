#### go语言的CSP模型

+ 这是一种用于描述两个独立的并发实体通过共享的通讯 Channel（管道）进行通信的并发模型。
+ Go的CSP模型实现与原始的CSP实现有点差别：原始的CSP中channel里的任务都是立即执行的，而go语言为其增加了一个缓存，即任务可以先暂存起来，等待执行线程准备好再顺序执行。
+ channel是Go语言中各个并发结构体(goroutine)之前的通信机制。 通俗的讲，就是各个goroutine之间通信的”管道“
+ 可以把channel理解成一个管子可以存放任何类型的数据即可

#### channel

+ 当申明一个channel时会在全局区产生一个hchan结构体的指针`8个字节`指向虚拟内存
  + buf 环形队列指针：就是管道内的数据在内存中存储的位置
  + sendx和recvx就是元素在这个管道队列里读出和写入的位置
  + recvq：
    + 当多个goroutine在读取某一个管道时会排队读取，如果没有数据则阻塞
    + 被阻塞的goroutine将会挂在channel的等待队列中
    + 因读阻塞的goroutine会被向channel写入数据的goroutine唤醒
  + sendq：
    + 就是当多个goroutinee往管道写数据时会排队写入，如果管道满了则阻塞
    + 被阻塞的goroutine将会挂在channel的等待队列中
    + 因写阻塞的goroutine会被从channel读数据的goroutine唤醒
  + ![01chan数据结构](./img\01chan数据结构.png)

#### 向一个channel中写数据简单过程如下：

1. 如果recvq（存放读取管道数据的协程队列）队列不为空，说明管道里没有数据（读协程大于写协程），那么此时直接从recvq取出G,并把写数据的协程数据写入该G，最后把该G唤醒，结束发送过程；
2. 如果管道里有空余位置（写协程大于读协程），将数据写入管道里，结束发送过程；

#### 从一个channel读数据简单过程如下：

1.  如果sendq（存放写管道数据的协程队列）队列不为空，且管道里没有数据，直接从sendq中取出G，把G中数据读出到读协程里，最后把G唤醒，结束读取过程；
2. 如果sendq队列不为空，管道里数据已满，从管道里首部读出数据到读协程里，把G中数据写入管道里尾部，把G唤醒，结束读取过程；
3. 如果缓冲区中有数据，则从缓冲区取出数据，结束读取过程

#### 关闭管道

+ 释放所有接收者：将所有读取的goroutine全部销毁，进行垃圾回收
+ 释放所有发送者：将所有写入的goroutine全部销毁，进行垃圾回收

#### 使用channel出现panic的常见场景有

+ 关闭已经被关闭的channel：因为此时的管道已经关闭，所以没法关闭
+ 向已经关闭的channel写数据：因为此时的管道已经关闭，没法写入
+ 读取没有关闭且为nil的channel：因为接收者和发送者的资源没有进行释放，SELECT内置的方默认将channel的资源已经释放所以可以用SELECT遍历管道

#### channel注意事项

##### 基本语法

```
var intchan chan int //定义管道
intchan=make(chan int,3)//给管道分配内存空间
intchan <- 10	//写入管道数据
firstDara:= <- intchan	//从管道里面读取数据
fmt.Println(firstDara)
```

##### 无缓冲管道

无缓冲管道就是必须读写同时操作才会有效果，如果只进行读或者只进行写那么会被阻塞，被暂时停顿等待另外一方的操作，是一个同步的过程，降低传输效率

```
ch:=make(chan int) //无缓冲管道
```

![](img/image-20210107134847032.png)



##### 有缓冲管道

channel 中自带缓冲区。创建时可以指定缓冲区的大小。写：直到缓冲区被填满后，写端才会阻塞。读：缓冲区被读空，读端才会阻塞。
len：代表缓冲区中，剩余元素个数，cap：代表缓冲区的容量。是一个异步步的过程，提高传输效率

```
ch:=make(chan int,10)//有缓冲管道
```



![WechatIMG23574](img/WechatIMG23574.png)



#### channel实战

将订单表的数通过协程和管道下载到execl表中，并且按照顺序，实现思路：

```
1、查询订单表总行数
2、定义一个有缓存管道 长度数 =  总单数/ 基数 比如：10 = 10000/1000
4、计算每个协程开始读或者写到开始行数并存放到管道里，比如：0，1000，2000，3000，4000，5000，6000，7000，8000，9000
5、启动10个协程
		1.读取管道内的开始行数
		2.按照对应的开始行数从mysql数据
		3.按照对应的开始行数写入到excel里即可
```











