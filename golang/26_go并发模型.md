#### 并发

+ 一个CPU上能同时执行多项任务，在很短时间内，CPU来回切换任务执行(在某段很短时间内执行程序a，然后又迅速得切换到程序b去执行)，有时间上的重叠（宏观上是同时的，微观仍是顺序执行）,这样看起来多个任务像是同时执行，这就是并发。

#### 并行

+ 当系统有多个CPU时,每个CPU同一时刻都运行任务，互不抢占自己所在的CPU资源，同时进行，称为并行。

#### 进程

+ 因为CPU在轮流的时候是先加载程序A的上下文，然后开始执行A，保存程序A的上下文，调入下一个要执行的程序B的程序上下文，然后开始执行B,保存程序B的上下文。。。。
+ 进程 = CPU加载上下文+CPU执行+CPU保存上下文

#### 线程

+ CPU切换多个进程的时候，会花费不少的时间，进程一旦多起来，CPU调度会消耗一大堆资源
+ 因此引入了线程的概念，线程本身几乎不占有资源，他们共享进程里的资源，内核调度起来不会那么像进程切换那么耗费资源。线程是共享了进程的上下文环境的更为细小的CPU时间段

#### 协程

+ 协程不是被操作系统内核所管理，而完全是由程序所控制（也就是在用户态执行`Goroutine`）。这样带来的好处就是性能得到了很大的提升，不会像线程那样需要上下文切换来消耗资源，因此协程的开销远远小于线程的开销，协程是共享了线程的上下文环境的更为细小的CPU时间段。

#### 宏观理解

+ 假如把一个厨师比作CPU,这个厨师会根据每个饭店提供的做菜步骤（程序）来做菜。
+ 现在有三个饭店（三个程序）：A饭店有一个做鱼肉的步骤、B饭店有一个做鸡肉的步骤、c饭店有一个牛肉的步骤。
+ 厨师做饭的工具（内核态）在南京、A饭店（用户态）在北京，B饭店（用户态）在上海，C饭店（用户态）在深圳相距很远。
+ 厨师会轮流的去这三家饭店做饭（进程），并且每个饭店做一会就回暂停再去另一家做，中间厨师还要回自己的家拿对应的厨具。一直循环直到做完为止
+ 后来将这三个店铺都合成一个店铺（多线程）地点在北京，主要是节省厨师的开销，把更多的经历放在做菜上。
  + 厨师只需要在厨房里进行轮流切换，切换的颗粒度变小
  + 这个厨房里的所有东西都是共用的，（内存共享）