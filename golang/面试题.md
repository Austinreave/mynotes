### 数据格式

#### 数组和切⽚

+ 请说明两个切⽚的不同
  
  ```
  msg：=[]int{1,2,3,4,5,6,7,8,9};
  sli1:=msg[2:3:4]
  sli2:=msg[2:3] 
  答：
  考点：切⽚容量
  解释：⾥⾯的数据⼀样，但是两个切⽚的容量不⼀样	容量 = max-low 	sli2 默认为1  sli1 为4
  ```
  
+ 写出⼀下程序运⾏的结果

  ```
  func main(){
    abc:=make([]int,2)
    abc=append(abc,1,2,3)
    fmt.Println(abc) 
  }
  答：
  考点：切⽚追加
  结果：[ 0 0 1 2 3]
  解释：切片在添加时会在原来的基础上新开辟一块内存和原来的互不影响
  ```

+ 写出⼀下程序运⾏的结果

  ```
  package main
  import "fmt"
  func main(){
    arr:=[]int{1,2,3,4,5,6,7,8}
    s1:=arr[2:6]
    s2:=s1[3:6] 
    fmt.Println("s1==",s1)
    fmt.Println("s2==",s2) 
  }
  答：
  考点：切⽚截取
  结果：s1== [3 4 5 6]	s2== [6 7 8]
  解释：切片的截取是将新的切片指向源切片的内存地址  修改一个会影响另外一个
  ```

+ 写出⼀下程序运⾏的结果

  ```
  package main
  import "fmt"
  func main() {
    s1 := []int{1, 2, 3}
    s2 := []int{4, 5}
    s1 = append(s1, s2)
    fmt.Println(s1) 
  }
  答：
  考点：append只能追加不定参，打碎的参数，所以append切⽚时候别漏了’…’
  结果：编译失败。
  ```

+ 解释Slice和Array的区别

  ```
  array是固定⻓度的数组，使⽤前必须确定数组⻓度
  slice是⼀个不定⻓的，总是指向底层的数组array的数据结构。slice是⼀个引⽤类型，是⼀个动态的指向数组切⽚的指针。
  数组是值类型，把⼀个数组赋予给另⼀个数组时是发⽣值拷⻉，⽽切⽚是指针类型，拷⻉的是指针。所以在golang的⽅法中即使是值传递切⽚，其实也是传递的指针。
  数组⼤⼩是固定的，切⽚⼤⼩不是。在运⾏时可以动态地增加或减少切⽚的⼤⼩，但数组不可以。
  ```

+ **slice**的底层实现

  ```
  slice底层存储了三个内容：地址、⻓度、容量。
  地址是指数据存储的位置。
  ⻓度表示有效数据的个数。
  容量表示本次（不更换地址）可以扩容的最⼤值。
  ⻓度和容量随着append的添加⽽改变，地址可能改变。
  ```

#### map

+ 写出⼀下程序运⾏的结果

  ```\
  package main
  import ( 
      "fmt"
  )
  func main(){
    dict:=map[string]int{"王五":60,"张三":43}
    modify(dict)
    fmt.Println(dict["张三"])
  }
  func modify(dict map[string]int){
  	dict["张三"]=10
  }
  答:
  考点：map作为函数参数，引⽤传递。
  结果：10
  解释：map作为函数参数是引⽤传递，形参可以修改实参的值。
  ```

+ 编译并运⾏如下代码会发⽣什么

  ```
  package main
  import "fmt"
  type Test struct {
    Name string
  }
  var list map[string]Test
  func main() {
    list = make(map[string]Test)
    list["name"] = Test{"xiaoming"}
    list["name"].Name = "Hello"
    fmt.Println(list["name"])
  }
  
  考点:map
  结果：编译失败。
  编程报错 cannot assign to struct field list["name"].Name in map 。 
  因为list[“name”]不是⼀个指针，改为list := make(map[string]*Test) ；list["name"] = &Test{"xiaoming"}即可
  ```

+ Map的键类型不能是哪些类型

  ```
  字典的键类型不能是以下类型：函数类型，hash类型，切⽚类型
  ```

####  数据定义

+ 是否可以编译通过？如果通过，输出什么

  ```
  package main
  import "fmt"
  const (
    x = iota
    y = "zz"
    k = iota
  )
  func main() {
  	fmt.Println(x,y,k)
  }
  答:
  考点：常量定义和iota枚举赋值
  结果：0 zz 2
  iota 换⾏值+1
  解释：
  1、iota常量自动生成器，每换一行，自动累加1 
  2、iota给常量赋值使用
  ```

+ 下⾯函数有什么问题

  ```
  package main
  const cl = 100
  var bl = 123
  func main() {
    println(&bl,bl)
    println(&cl,cl)
  }
  答：
  考点:常量
  结果：编译失败。
  常量不同于变量的在运⾏期分配内存，常量通常会被编译器在预处理阶段直接展开，作为指令数据使⽤，报错：cannot take the address。
  ```

+ 编译执⾏下⾯代码会出现什么

  ```
  package main
  import "fmt"
  func main() {
    type MyInt1 int
    type MyInt2 = int
    var i int = 9
    var i1 MyInt1 = i
    var i2 MyInt2 = i
    fmt.Println(i1,i2) 
  }
  考点：type起别名
  基于⼀个类型创建⼀个新类型，称之为defintion(定义新类型)；基于⼀个类型创建⼀个别名，称之为alias。MyInt1为称之为defintion，虽然底层类型为int类型，但是不能直接赋值，需要强转（var i1 MyInt1 = MyInt1(i)）； MyInt2称之为alias，可以直接赋值。
  结果:编译失败。报错：annot use i (type int) as type MyInt1 in assignment。
  ```

+ string和[]byte的区别

  ```
  package main
  import "fmt"
  func main() {
    s := "qqqq"
    b := []byte("你好，hello")
    fmt.Println(s[1])
    fmt.Println(b[1])
  }
  
  共同点：可以互相转化、都可以通过下标索引
  不同点：
  1、[]byte可以通过下标修改值,string不可以
  2、string可以⽐较，[]byte不可以⽐较,所以[]byte不能作为map的key值 
  3、[]byte在传输性能⽅⾯要⽐string好 
  4、string的值不可以为nil，所以如果需要nil的特性，就得⽤[]byte
  ```

####  指针

+ 是否可以编译通过？如果通过，输出什么

  ```
  func main() {
    list := new([]int)
    list = append(list, 1)
    fmt.Println(list) 
  }
  考点：new和make
  结果：编译失败。
  ⼆者都是内存的分配（堆上），但是make只⽤于slice、map以及channel的初始化（⾮零值）；⽽new⽤于类型的内存分配，并且内存置为零。所以在我们编写程序的时候，就可以根据⾃⼰的需要很好的选择了。
  make返回的还是这三个引⽤类型本身；⽽new返回的是指向类型的指针。
  ```

####  interface

+ 以下代码输出什么

  ```
  package main
  import "fmt"
  func main() {
    i := GetValue()
    switch i.(type) {
    case int:
    fmt.Println("int")
    case string:
    fmt.Println("string")
    case interface{}:
    fmt.Println("interface")
    default:
    fmt.Println("unknown") } }
    func GetValue() int {
    return 1
  }
  答：
  考点：interface{}类型和type
  结果：编译失败。
  解释：因为type只能使⽤在interface
  ```

#### 函数和闭包

+ 下⾯函数有什么问题

  ```
  package main
  func main() {
    for i:=0;i<10 ;i++ {
    loop:
    println(i)
  }
  	goto loop
  }
  答：
  考点：goto跳转语句
  结果：编译失败。
  解释：goto不能跳转到其他函数或者内层代码，报错：goto loop jumps into block starting at。
  ```

+ 编译执⾏下⾯代码会出现什么

  ```
  package main
  func test(x int) (func(),func()) {
    return func() {
    println(x)
    x+=10
    }, func() {
    println(x)
    }
  }
  func main() {
    a,b:=test(100)
    a()
    b()
  }
  
  答案:
  100
  110
  考点：闭包引⽤相同变量 结果
  解释：
  闭包的特点
  1、可以读取函数内部的变量
  2、变量的值始终保持在内存中
  ```

+ 使⽤reflect输出类型与值

   ```
  package main
  import (
    "fmt"
    "reflect"
  )
  func main(){
    var num = 1.2345
    //使⽤reflect输出类型与值
    //类型
    fmt.Println(reflect.TypeOf(num))
    //值
    fmt.Println(reflect.ValueOf(num))
  }
   ```

  