### goroutine调度模型

##### 协程特点

+ 有独立的栈空间（指向自己的函数）
+ 共享程序的堆空间（数据存储的地方）
+ 调度由用户控制
+ 协程是轻量级线程

##### MPG特点

+ 是用户态的自己来维护各个协程之间的调用

##### MPG介绍

+ **Machine** : 主线程或者进程main函数的入口函数
+ **Processor**：指承载多个goroutine的运行器，运行协程的上下文环境
+ **Goroutine** : 指应用里创建的goroutine

#### MPG 模式运行的状态 1

+ 一个Machine会对应一个内核线程（K），同时会有一个Processor与它绑定。一个Processor连接一个或者多个Goroutine。Processor有一个运行时的Goroutine（上图中绿色的G），其它的Goroutine处于等待状态。
+ Processor可通过GOMAXPROCS限制同时执行用户级任务的操作系统线程。GOMAXPROCS值默认是CPU的可用核心数，但是其数量是可以指定的。

+ ![image-20200704132207774](./img\image-20200704132207774.png)



#### MPG 模式运行的状态 2

![image-20200704132723107](.\img\image-20200704132723107.png)

#### 说一下MPG调度模型

+ go之所以能处理高并发，就是因为有MPG调度，它是用户态的，由程序自己控制，不受操作系统控制，比如当操作系统给某个主线程运行权限时，此时MPG里面可开启成千上万的协程，由Seched调度器自己来维护，这样就能在有限的cpu运行期间内干更多的事

+ 具体调用细节：

  当一个程序启动了A、B、C三个协程(G)，当主线程（M）假如阻塞（读取文件），此时处理器（P）会让Seched调度器开启一个新的主线程，这个主线程可能是从线程池里取过来的，也可能是新创建的（可能创建的不同的CPU上面，这个根据系统的CPU个数决定），此时会把A、B、C这个队列里的协程挂载这个新的线程上运行，当原来的主线程运行完时，会将资源存放到线程池里供下次使用，从而达到高并发效果。
