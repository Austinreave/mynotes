#### 锁分类

+ 读锁（共享锁）：针对同一份数据，多个读操作可以同时进行而不会互相影响。

+ 写锁（排它锁）：当前操作没有完成之前，它会阻断其他写锁和读锁。

#### MyISAM 表锁

+ MyISAM 存储引擎只支持表锁，这也是MySQL开始几个版本中唯一支持的锁类型。
+ 对MyISAM 表的读操作，不会阻塞其他用户对同一表的读请求，但会阻塞对同一表的写请求；
+ 对MyISAM 表的写操作，则会阻塞其他用户对同一表的读和写操作；

​	简而言之，就是读锁会阻塞写，但是不会阻塞读。而写锁，则既会阻塞读，又会阻塞写。

#### InnoDB 行锁

+ 偏向InnoDB 存储引擎，开销大，加锁慢；会出现死锁；
+ 锁定粒度最小，发生锁冲突的概率最低,并发度也最高。
+ InnoDB 与 MyISAM 的最大不同有两点：一是支持事务；二是采用了行级锁。

**事务及其ACID属性**

事务是由一组SQL语句组成的逻辑处理单元。事务具有以下4个特性，简称为事务ACID属性。

| ACID属性             | 含义                         |
| -------------------- | ---------------------------- |
| 原子性（Atomicity）  | 要么全部成功，要么全部失败。 |
| 一致性（Consistent） | 数据都必须保持一致状态。     |
| 隔离性（Isolation）  | 不受外界影响                 |
| 持久性（Durable）    | 对于数据的修改是永久的。     |

**并发事务处理带来的问题**

| 问题                               | 含义                                                         |
| ---------------------------------- | ------------------------------------------------------------ |
| 丢失更新（Lost Update）            | 当两个或多个事务选择同一行，最初的事务修改的值，会被后面的事务修改的值覆盖。 |
| 脏读（Dirty Reads）                | 事务A读到了事务B未提交的数据                                 |
| 不可重复读（Non-Repeatable Reads） | 一个事务范围内两个相同的查询却返回了不同数据。比如：事务A第一次查询得到一行记录row1，事务B提交修改后，事务A第二次查询得到row1，但列内容发生了变化 |
| 幻读（Phantom Reads）              | 后一次查询看到了前一次查询没有看到的行。比如：事务A第一次查询得到一行记录row1，事务B提交添加后，事务A第二次查询得到两行记录row1和row2 |

**事务隔离级别**

数据库的隔离级别有4个，由低到高依次为Read uncommitted、Read committed、Repeatable read、Serializable，这四个级别可以逐个解决脏写、脏读、不可重复读、幻读这几类问题。

| 隔离级别                                                     | 丢失更新 | 脏读 | 不可重复读 | 幻读 |
| ------------------------------------------------------------ | -------- | ---- | ---------- | ---- |
| Read uncommitted：就是一个事务可以读取另一个未提交事务的数据脏读 | ×        | √    | √          | √    |
| Read committed：就是一个事务要等另一个事务提交后才能读取数据 | ×        | ×    | √          | √    |
| Repeatable read（默认）：就是事务开启时，不再允许修改操作    | ×        | ×    | ×          | √    |
| Serializable：这种事务隔离级别效率低下，比较耗数据库性能，一般不使用 | ×        | ×    | ×          | ×    |

备注 ： √  代表可能出现 ， × 代表不会出现 。

##### 总结

InnoDB存储引擎由于实现了行级锁定，虽然在锁定机制的实现方面带来了性能损耗可能比表锁会更高一些，但是在整体并发处理能力方面要远远低于MyISAM的表锁的。当系统并发量较高的时候，InnoDB的整体性能和MyISAM相比就会有比较明显的优势。但是，InnoDB的行级锁同样也有其脆弱的一面，当我们使用不当的时候，可能会让InnoDB的整体性能表现不仅不能比MyISAM高，甚至可能会更差。
