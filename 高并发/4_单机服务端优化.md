### 重复提交优化：

1. js层面，在用户点击提交订单后禁用按钮。
2. 使用Redis incrde 原子性递增计数

```
//针对同一单生成固定唯一标识
orderNum=memberId+productId;

//条数加1
count = redis.increment(orderNum, 1);
if (count == 1) {
	//设置有效期2秒
  redis.expire(orderNum, 2, TimeUnit.SECONDS);
}

if (count > 1) {
   resultMap.put("retCode", "500");     
   resultMap.put("retMsg", "请不要重复提交订单");
   return resultMap;
}
```



### 操作同一条数据优化

**FOR UPDATE注意事项**

+ 在mysql中FOR UPDATE时，如果查询条件带有主键会锁行数据，如果没有则会锁表数据。
+ 如果查询一条正在执行事务的数据时使用了FOR UPDATE 此时程序会进行阻塞，直到事务进行提交或者回滚时才会查询出结果。

**FOR UPDATE使用场景**

当商户取消某一个订单时，此时用户正在支付此笔订单，当程序运行到查询此笔【待支付】订单金额时需要使用 FOR UPDATE ，然而程序一直会阻塞，直到商户取消完订单【已取消】事务提交后，此时查询结果会显示查询订单不存在，避免了错误支付的情况。



### 大表数据查询

。。。

### 增加缓存

#### redis

。。。

#### elasticsearch

。。。。



### 3 分库分表

#### 分库

+ 会涉及到分布式事务来保证数据的一致性
+ 在生成唯一单号时要在中台服务生成供后台使用

#### 分表

+ 通过哈希算法均匀的分配到不同的表里面

+ Mycat它是数据库中间件，可通过它来组织数据库的分离读写和分库分表，客户端通过它来访问下层数据库，还会涉及数据同步，数据一致性的问题。

##### 水平拆分表

就是把一个表的数据拆分到多个库的多个表里面去。这里面的每个库的表结构都是一样的，只不过是表中存放的数据不一样，每个库表的数据汇总起来就是全部数据。

##### 垂直拆分表

就是把一个有很多字段的表给拆分成多个表或者多个库上面去，每个库表的结构都不一样，每个库表都包含部分字段。一般来说，会将较少的访问频率很高的字段放到一个表里面去，然后将较多的访问频率很低的字段放到另外一个表里面去。



### 4 高问量处理

#### 分流

#### 熔断

#### 降级

#### 监控

#### 日志

